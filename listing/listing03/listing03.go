package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}

//Ответ:
//
//<nil>
//false

//Значение интерфейса равно nil, только если его значение и динамический тип равны nil. В приведенном выше примере Foo() возвращает [nil, *os.PathError],
//и мы сравниваем его с [nil, nil].
//
//Можно подумать о значении интерфейса nil как о типизированном, и nil без типа не равен nil с типом.
//Если мы конвертируем nil в правильный тип, значения действительно равны.
//
//fmt.Println(err == (*os.PathError)(nil)) // true
//Чтобы избежать этой проблемы, необходимо использовать вместо этого переменную типа error, например именованное возвращаемое значение.
//
//func Foo() (err error) {
//    // …
//    // err не назначен и имеет нулевое значение [nil, nil]
//    return
//}

//func main() {
//    err := Foo()
//    fmt.Println(err)        // <nil>
//    fmt.Println(err == nil) // true
//}
//Лучше использовать встроенный тип интерфейса error, а не конкретный тип, для хранения и возврата значений ошибок.
//
//Внутреннее устройство интерфейса следующее:

//type iface struct {
//    tab  *itab
//    data unsafe.Pointer
//}

//где tab — это указатель на Interface Table или itab — структуру, которая хранит некоторые метаданные о типе и список методов,
//используемых для удовлетворения интерфейса.
//data — указывает на фактическую переменную с конкретным (статическим) типом.
//
//Пустой интерфейс не содержит никаких методов, поэтому ему не нужно хранить указатели
//Пустой интерфейс отличается тем, что он ничего не означает, никакой абстракции, и не дает никакого понимания о поведении
